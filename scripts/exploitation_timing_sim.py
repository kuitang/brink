#!/usr/bin/env python3
"""Exploitation Timing Analysis - find optimal defection turn.

Simulates games where Player A defects exactly once at turn N,
measuring payoff to determine if late-game defection is dominant.

This validates that capture mechanics don't create a dominant "late defection" strategy.
If the peak defection turn is 12+, it indicates late-defection dominance which may
require enabling STREAK_PROTECTION in parameters.py.

Usage:
    uv run python scripts/exploitation_timing_sim.py --games 100

    # Run with specific scenario
    uv run python scripts/exploitation_timing_sim.py --scenario cuban_missile_crisis --games 100

    # Run with reproducible seed
    uv run python scripts/exploitation_timing_sim.py --games 100 --seed 42

See GAME_MANUAL.md Appendix C.6 for simulation specifications.
"""

from __future__ import annotations

import argparse
import asyncio
import statistics
import time
from concurrent.futures import ProcessPoolExecutor, as_completed
from dataclasses import dataclass, field
from typing import Optional

from brinksmanship.engine.game_engine import EndingType, GameEngine
from brinksmanship.models.actions import Action, ActionType
from brinksmanship.models.state import GameState
from brinksmanship.opponents.base import Opponent, SettlementProposal, SettlementResponse
from brinksmanship.opponents.deterministic import TitForTat
from brinksmanship.storage import get_scenario_repository


@dataclass
class TimingResult:
    """Result for a single defection timing point."""

    defect_turn: int
    games_played: int = 0
    surplus_captured_list: list[float] = field(default_factory=list)
    position_a_list: list[float] = field(default_factory=list)
    vp_a_list: list[float] = field(default_factory=list)
    wins_a: int = 0
    wins_b: int = 0
    ties: int = 0
    mutual_destructions: int = 0

    def add_game(
        self,
        surplus_captured: float,
        position_a: float,
        vp_a: float,
        winner: str,
    ) -> None:
        """Add a game result to the statistics."""
        self.games_played += 1
        self.surplus_captured_list.append(surplus_captured)
        self.position_a_list.append(position_a)
        self.vp_a_list.append(vp_a)

        if winner == "A":
            self.wins_a += 1
        elif winner == "B":
            self.wins_b += 1
        elif winner == "tie":
            self.ties += 1
        elif winner == "mutual_destruction":
            self.mutual_destructions += 1

    @property
    def avg_surplus_captured(self) -> float:
        """Average surplus captured by Player A."""
        if not self.surplus_captured_list:
            return 0.0
        return statistics.mean(self.surplus_captured_list)

    @property
    def avg_position(self) -> float:
        """Average final position for Player A."""
        if not self.position_a_list:
            return 0.0
        return statistics.mean(self.position_a_list)

    @property
    def avg_vp(self) -> float:
        """Average VP for Player A."""
        if not self.vp_a_list:
            return 0.0
        return statistics.mean(self.vp_a_list)

    @property
    def win_rate(self) -> float:
        """Win rate for Player A."""
        if self.games_played == 0:
            return 0.0
        return self.wins_a / self.games_played


class TimedDefector(Opponent):
    """Opponent that defects exactly once at a specified turn.

    Cooperates on all turns except the specified defection turn.
    Used to measure the payoff of defecting at different points in the game.
    """

    def __init__(self, defect_turn: int) -> None:
        """Initialize with the turn to defect on.

        Args:
            defect_turn: The turn number (1-indexed) to defect on.
                        Cooperates on all other turns.
        """
        super().__init__(name=f"TimedDefector(turn={defect_turn})")
        self.defect_turn = defect_turn
        self._is_player_a: bool = True
        self._defected: bool = False

    def set_player_side(self, is_player_a: bool) -> None:
        """Set which side this opponent is playing."""
        self._is_player_a = is_player_a

    async def choose_action(
        self, state: GameState, available_actions: list[Action]
    ) -> Action:
        """Choose action based on timed defection strategy.

        Defects only on the specified turn, cooperates otherwise.
        """
        # Determine action type for this turn
        if state.turn == self.defect_turn and not self._defected:
            self._defected = True
            action_type = ActionType.COMPETITIVE
        else:
            action_type = ActionType.COOPERATIVE

        # Find an action of the desired type
        typed_actions = [a for a in available_actions if a.action_type == action_type]
        if typed_actions:
            return typed_actions[0]

        # Fallback to any action if none of desired type
        return available_actions[0] if available_actions else Action(
            name="Hold", action_type=ActionType.COOPERATIVE, description="Hold"
        )

    async def evaluate_settlement(
        self,
        proposal: SettlementProposal,
        state: GameState,
        is_final_offer: bool,
    ) -> SettlementResponse:
        """Reject all settlement proposals - we're testing defection timing."""
        return SettlementResponse(
            action="reject",
            rejection_reason="Testing exploitation timing - no settlement.",
        )

    async def propose_settlement(self, state: GameState) -> SettlementProposal | None:
        """Never propose settlement - we're testing defection timing."""
        return None


def _run_single_timing_game(args: tuple) -> dict:
    """Worker function for running a single timed defection game.

    Args:
        args: Tuple of (scenario_id, defect_turn, seed)

    Returns:
        Dict with game results
    """
    scenario_id, defect_turn, seed = args

    # Create opponents: TimedDefector as A, TitForTat as B
    defector = TimedDefector(defect_turn)
    defector.set_player_side(is_player_a=True)

    responder = TitForTat()
    responder.set_player_side(is_player_a=False)

    # Get scenario repository
    repo = get_scenario_repository()

    # Create game engine
    engine = GameEngine(scenario_id, repo, random_seed=seed)

    # Run game
    while not engine.is_game_over():
        state = engine.get_current_state()
        actions_a = engine.get_available_actions("A")
        actions_b = engine.get_available_actions("B")

        # Get actions (sync since our opponents are deterministic)
        action_a = asyncio.run(defector.choose_action(state, actions_a))
        action_b = asyncio.run(responder.choose_action(state, actions_b))

        # Submit and check for ending
        result = engine.submit_actions(action_a, action_b)

        # Update GrimTrigger-like state in TitForTat if needed
        if hasattr(responder, "receive_result") and result.action_result:
            responder.receive_result(result.action_result)

        if result.ending:
            break

    # Get final state and ending
    final_state = engine.get_current_state()
    ending = engine.get_ending()

    # Determine winner and VP
    if ending:
        vp_a = ending.vp_a
        vp_b = ending.vp_b
        if ending.ending_type == EndingType.MUTUAL_DESTRUCTION:
            winner = "mutual_destruction"
        elif vp_a > vp_b + 0.01:
            winner = "A"
        elif vp_b > vp_a + 0.01:
            winner = "B"
        else:
            winner = "tie"
    else:
        vp_a = 50.0
        vp_b = 50.0
        winner = "tie"

    return {
        "defect_turn": defect_turn,
        "surplus_captured_a": final_state.surplus_captured_a,
        "position_a": final_state.position_a,
        "vp_a": vp_a,
        "winner": winner,
        "turns_played": final_state.turn - 1,
    }


def run_timing_analysis(
    scenario_id: str = "cuban_missile_crisis",
    games_per_turn: int = 100,
    max_defect_turn: int = 14,
    seed: Optional[int] = None,
    max_workers: int = 4,
    quiet: bool = False,
) -> dict[int, TimingResult]:
    """Run the exploitation timing analysis.

    For each defection turn from 1 to max_defect_turn, runs multiple games
    where Player A cooperates until that turn, defects once, then cooperates.
    Player B uses TitForTat (retaliates after defection).

    Args:
        scenario_id: Scenario to use for simulation
        games_per_turn: Number of games to run per defection turn
        max_defect_turn: Maximum turn to test defection on
        seed: Base random seed (game i uses seed + i)
        max_workers: Number of parallel workers
        quiet: Suppress progress output

    Returns:
        Dict mapping defection turn to TimingResult
    """
    results: dict[int, TimingResult] = {}

    # Initialize results for each turn
    for turn in range(1, max_defect_turn + 1):
        results[turn] = TimingResult(defect_turn=turn)

    # Prepare all game arguments
    all_args = []
    game_idx = 0
    for defect_turn in range(1, max_defect_turn + 1):
        for game in range(games_per_turn):
            game_seed = (seed + game_idx) if seed is not None else None
            all_args.append((scenario_id, defect_turn, game_seed))
            game_idx += 1

    # Run games in parallel
    total_games = len(all_args)
    completed = 0

    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        futures = {executor.submit(_run_single_timing_game, args): args for args in all_args}

        for future in as_completed(futures):
            result_dict = future.result()
            defect_turn = result_dict["defect_turn"]

            results[defect_turn].add_game(
                surplus_captured=result_dict["surplus_captured_a"],
                position_a=result_dict["position_a"],
                vp_a=result_dict["vp_a"],
                winner=result_dict["winner"],
            )

            completed += 1
            if not quiet and completed % (total_games // 10 or 1) == 0:
                pct = (completed / total_games) * 100
                print(f"  Progress: {completed}/{total_games} ({pct:.0f}%)")

    return results


def find_optimal_turn(results: dict[int, TimingResult]) -> tuple[int, float]:
    """Find the optimal defection turn based on total VP.

    Args:
        results: Dict of TimingResults by defection turn

    Returns:
        Tuple of (optimal_turn, avg_vp_at_that_turn)
    """
    best_turn = 1
    best_vp = 0.0

    for turn, result in results.items():
        if result.avg_vp > best_vp:
            best_vp = result.avg_vp
            best_turn = turn

    return best_turn, best_vp


def print_results(
    results: dict[int, TimingResult],
    scenario_id: str,
    games_per_turn: int,
) -> None:
    """Print formatted results table.

    Args:
        results: Dict of TimingResults by defection turn
        scenario_id: Scenario ID used
        games_per_turn: Number of games per defection turn
    """
    print()
    print("EXPLOITATION TIMING ANALYSIS")
    print("=" * 80)
    print(f"Scenario: {scenario_id}")
    print(f"Games per turn: {games_per_turn}")
    print()

    # Find optimal turn for highlighting
    optimal_turn, optimal_vp = find_optimal_turn(results)

    # Print table header
    print(f"{'Defect Turn':^12} | {'Avg Surplus':^12} | {'Avg Position':^13} | {'Total VP':^10} | {'Win Rate':^10}")
    print("-" * 80)

    # Print each turn's results
    for turn in sorted(results.keys()):
        result = results[turn]
        is_peak = turn == optimal_turn

        surplus_str = f"{result.avg_surplus_captured:.1f}"
        position_str = f"{result.avg_position:.1f}"
        vp_str = f"{result.avg_vp:.1f}"
        win_rate_str = f"{result.win_rate * 100:.0f}%"

        peak_marker = " <- PEAK" if is_peak else ""

        print(
            f"{turn:^12} | {surplus_str:^12} | {position_str:^13} | {vp_str:^10} | {win_rate_str:^10}{peak_marker}"
        )

    print("-" * 80)
    print()

    # Analyze the result
    if optimal_turn >= 12:
        print(f"Optimal defection turn: {optimal_turn} (late-game)")
        print()
        print("WARNING: Late defection dominance detected (optimal turn: {})".format(optimal_turn))
        print("Consider enabling STREAK_PROTECTION in parameters.py")
        print()
        print("The optimal defection turn should be mid-game (turns 5-9) to ensure")
        print("balanced gameplay. Late-game defection dominance means players can")
        print("'wait and betray' for maximum payoff, which undermines cooperation.")
    elif optimal_turn >= 9:
        print(f"Optimal defection turn: {optimal_turn} (late mid-game)")
        print()
        print("CAUTION: Defection timing is on the later side.")
        print("Monitor for late-defection dominance if parameters change.")
    elif optimal_turn >= 5:
        print(f"Optimal defection turn: {optimal_turn} (mid-game)")
        print()
        print("No late-defection dominance detected.")
        print("The game creates meaningful tradeoffs between early and late defection.")
    else:
        print(f"Optimal defection turn: {optimal_turn} (early-game)")
        print()
        print("Early defection appears optimal. This suggests:")
        print("- Surplus accumulation may be too slow")
        print("- Consider increasing SURPLUS_BASE or SURPLUS_STREAK_BONUS")

    # Additional statistics
    print()
    print("Additional Statistics:")
    print("-" * 40)

    total_md = sum(r.mutual_destructions for r in results.values())
    total_games = sum(r.games_played for r in results.values())
    md_rate = total_md / total_games if total_games > 0 else 0

    print(f"Mutual destruction rate: {md_rate * 100:.1f}%")

    # VP distribution
    all_vps = []
    for r in results.values():
        all_vps.extend(r.vp_a_list)

    if all_vps:
        print(f"Player A VP range: {min(all_vps):.1f} - {max(all_vps):.1f}")
        print(f"Player A VP std dev: {statistics.stdev(all_vps):.1f}")


def main() -> None:
    """Run the exploitation timing simulation."""
    parser = argparse.ArgumentParser(
        description="Exploitation Timing Analysis - find optimal defection turn",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
This script determines the optimal turn to defect in Brinksmanship.

If the optimal turn is 12+, it indicates late-defection dominance:
players can "cooperate until the end, then betray" for maximum gain.
This is a balance problem that may require enabling STREAK_PROTECTION.

The target is for the optimal turn to be mid-game (turns 5-9), creating
meaningful strategic tension throughout the game.

Examples:
    uv run python scripts/exploitation_timing_sim.py --games 100
    uv run python scripts/exploitation_timing_sim.py --scenario cuban_missile_crisis --games 200
    uv run python scripts/exploitation_timing_sim.py --games 50 --seed 42
        """,
    )

    parser.add_argument(
        "--scenario",
        type=str,
        default="cuban_missile_crisis",
        help="Scenario ID to use (default: cuban_missile_crisis)",
    )
    parser.add_argument(
        "--games",
        type=int,
        default=100,
        help="Number of games per defection turn (default: 100)",
    )
    parser.add_argument(
        "--max-turn",
        type=int,
        default=14,
        help="Maximum turn to test defection on (default: 14)",
    )
    parser.add_argument(
        "--seed",
        type=int,
        default=None,
        help="Random seed for reproducibility",
    )
    parser.add_argument(
        "--workers",
        type=int,
        default=4,
        help="Number of parallel workers (default: 4)",
    )
    parser.add_argument(
        "--quiet",
        action="store_true",
        help="Suppress progress output",
    )

    args = parser.parse_args()

    print("=" * 80)
    print("BRINKSMANSHIP EXPLOITATION TIMING SIMULATION")
    print("=" * 80)
    print(f"Scenario: {args.scenario}")
    print(f"Games per defection turn: {args.games}")
    print(f"Testing defection turns: 1 to {args.max_turn}")
    print(f"Workers: {args.workers}")
    if args.seed is not None:
        print(f"Seed: {args.seed}")
    print()
    print("Running simulation...")

    start_time = time.time()

    results = run_timing_analysis(
        scenario_id=args.scenario,
        games_per_turn=args.games,
        max_defect_turn=args.max_turn,
        seed=args.seed,
        max_workers=args.workers,
        quiet=args.quiet,
    )

    duration = time.time() - start_time

    print_results(results, args.scenario, args.games)

    print()
    print(f"Simulation completed in {duration:.1f} seconds")
    print("=" * 80)


if __name__ == "__main__":
    main()
